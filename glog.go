package glog

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"runtime"
	"strings"
	"sync"
	"time"

	"github.com/winterssy/bufferpool"
)

// Logging output level.
const (
	Ldebug = iota
	Linfo
	Lwarn
	Lerror
	Lpanic
	Lfatal
)

var levels = [...]string{
	"DEBUG",
	"INFO",
	"WARN",
	"ERROR",
	"PANIC",
	"FATAL",
}

// These flags define which text to prefix to each log entry generated by the Logger.
// Bits are or'ed together to control what's printed.
// There is no control over the order they appear (the order listed
// here) or the format they present (as described in the comments).
// The prefix is followed by a colon only when Llongfile or Lshortfile
// is specified.
// For example, flags Ldate | Ltime (or LstdFlags) produce,
// 	2009-01-23 01:23:23 [level] message
// while flags Ldate | Ltime | Lmilliseconds | Llongfile produce,
// 	2009-01-23 01:23:23,123 [level] /a/b/c/d.go:23: message
const (
	Ldate         = 1 << iota                     // the date in the local time zone: 2009-01-23
	Ltime                                         // the time in the local time zone: 01:23:23
	Lmilliseconds                                 // millisecond resolution: 01:23:23,123. assumes Ltime.
	Llongfile                                     // full file name and line number: /a/b/c/d.go:23
	Lshortfile                                    // package file name element and line number: package/d.go:23. overrides Llongfile
	LUTC                                          // if Ldate or Ltime is set, use UTC rather than the local time zone
	Lmsgprefix                                    // move the "prefix" from the beginning of the line to before the message
	LstdFlags     = Ldate | Ltime | Lmilliseconds // initial values for the standard logger
)

// A Logger represents an active logging object that generates lines of
// output to an io.Writer. Each logging operation makes a single call to
// the Writer's Write method. A Logger can be used simultaneously from
// multiple goroutines; it guarantees to serialize access to the Writer.
type Logger struct {
	prefix string     // prefix to write at beginning of each line
	flag   int        // properties
	level  int        // output level
	out    io.Writer  // destination for output
	mu     sync.Mutex // ensures atomic writes
}

var _globalL = New(os.Stderr, "", LstdFlags, Linfo)

// New creates a new Logger. The out variable sets the
// destination to which log data will be written.
// The prefix appears at the beginning of each generated log line.
// The flag argument defines the logging properties.
// The level argument defines the logging output level.
func New(out io.Writer, prefix string, flag int, level int) *Logger {
	return &Logger{out: out, prefix: prefix, flag: flag, level: level}
}

// ReplaceGlobal replaces the global Logger.
func ReplaceGlobal(logger *Logger) {
	_globalL = logger
}

// Cheap integer to fixed-width decimal ASCII. Give a negative width to avoid zero-padding.
func itoa(buf *bytes.Buffer, i int, wid int) {
	// Assemble decimal in reverse order.
	var b [20]byte
	bp := len(b) - 1
	for i >= 10 || wid > 1 {
		wid--
		q := i / 10
		b[bp] = byte('0' + i - q*10)
		bp--
		i = q
	}
	// i < 10
	b[bp] = byte('0' + i)
	buf.Write(b[bp:])
}

func trimmedPath(filename string) string {
	idx := strings.LastIndexByte(filename, '/')
	if idx == -1 {
		return filename
	}
	// Find the penultimate separator.
	idx = strings.LastIndexByte(filename[:idx], '/')
	if idx == -1 {
		return filename
	}
	return filename[idx+1:]
}

// formatHeader writes log header to buf in following order:
//   * l.prefix (if it's not blank),
//   * date and/or time (if corresponding flags are provided),
//   * l.level,
//   * file and line number (if corresponding flags are provided).
func (l *Logger) formatHeader(buf *bytes.Buffer, t time.Time, file string, line int, level int) {
	if l.flag&Lmsgprefix == 0 {
		buf.WriteString(l.prefix)
	}

	if l.flag&(Ldate|Ltime|Lmilliseconds) != 0 {
		if l.flag&LUTC != 0 {
			t = t.UTC()
		}
		if l.flag&Ldate != 0 {
			year, month, day := t.Date()
			itoa(buf, year, 4)
			buf.WriteByte('-')
			itoa(buf, int(month), 2)
			buf.WriteByte('-')
			itoa(buf, day, 2)
			buf.WriteByte(' ')
		}
		if l.flag&(Ltime|Lmilliseconds) != 0 {
			hour, min, sec := t.Clock()
			itoa(buf, hour, 2)
			buf.WriteByte(':')
			itoa(buf, min, 2)
			buf.WriteByte(':')
			itoa(buf, sec, 2)
			if l.flag&Lmilliseconds != 0 {
				buf.WriteByte(',')
				itoa(buf, t.Nanosecond()/1e6, 3)
			}
			buf.WriteByte(' ')
		}
	}

	// format message level
	buf.WriteString("[" + levels[level] + "]")
	buf.WriteByte(' ')

	if l.flag&(Lshortfile|Llongfile) != 0 {
		if l.flag&Lshortfile != 0 {
			file = trimmedPath(file)
		}
		buf.WriteString(file)
		buf.WriteByte(':')
		itoa(buf, line, -1)
		buf.WriteByte(' ')
	}

	if l.flag&Lmsgprefix != 0 {
		buf.WriteString(l.prefix)
	}
}

// atomic write.
func (l *Logger) write(b []byte) (int, error) {
	l.mu.Lock()
	defer l.mu.Unlock()
	return l.out.Write(b)
}

// Output writes the output for a logging event.
// The string msg contains the text to print after the prefix specified by the flags of the Logger.
// A newline is appended if the last character of s is not already a newline.
// The level argument specifies the log message level.
// The calldepth argument specifies the count of the number of frames to skip
// when computing the file name and line number if Llongfile or Lshortfile is set.
func (l *Logger) Output(level int, calldepth int, msg string) error {
	now := time.Now() // get this early.
	var file string
	var line int

	if l.flag&(Lshortfile|Llongfile) != 0 {
		var ok bool
		_, file, line, ok = runtime.Caller(calldepth)
		if !ok {
			file = "???"
			line = 0
		}
	}

	buf := bufferpool.Get()
	defer buf.Free()
	l.formatHeader(buf.Buffer, now, file, line, level)
	buf.WriteString(msg)
	if len(msg) == 0 || msg[len(msg)-1] != '\n' {
		buf.WriteByte('\n')
	}
	_, err := l.write(buf.Bytes())
	return err
}

// Debug uses fmt.Sprintln to construct and log a message.
func (l *Logger) Debug(v ...interface{}) {
	if Ldebug >= l.level {
		l.Output(Ldebug, 2, fmt.Sprintln(v...))
	}
}

// Debugf uses fmt.Sprintf to construct and log a message.
func (l *Logger) Debugf(format string, v ...interface{}) {
	if Ldebug >= l.level {
		l.Output(Ldebug, 2, fmt.Sprintf(format, v...))
	}
}

// Info uses fmt.Sprintln to construct and log a message.
func (l *Logger) Info(v ...interface{}) {
	if Linfo >= l.level {
		l.Output(Linfo, 2, fmt.Sprintln(v...))
	}
}

// Infof uses fmt.Sprintf to construct and log a message.
func (l *Logger) Infof(format string, v ...interface{}) {
	if Linfo >= l.level {
		l.Output(Linfo, 2, fmt.Sprintf(format, v...))
	}
}

// Warn uses fmt.Sprintln to construct and log a message.
func (l *Logger) Warn(v ...interface{}) {
	if Lwarn >= l.level {
		l.Output(Lwarn, 2, fmt.Sprintln(v...))
	}
}

// Warnf uses fmt.Sprintf to construct and log a message.
func (l *Logger) Warnf(format string, v ...interface{}) {
	if Lwarn >= l.level {
		l.Output(Lwarn, 2, fmt.Sprintf(format, v...))
	}
}

// Error uses fmt.Sprintln to construct and log a message.
func (l *Logger) Error(v ...interface{}) {
	if Lerror >= l.level {
		l.Output(Lerror, 2, fmt.Sprintln(v...))
	}
}

// Errorf uses fmt.Sprintf to construct and log a message.
func (l *Logger) Errorf(format string, v ...interface{}) {
	if Lerror >= l.level {
		l.Output(Lerror, 2, fmt.Sprintf(format, v...))
	}
}

// Panic uses fmt.Sprintln to construct and log a message, then panics.
func (l *Logger) Panic(v ...interface{}) {
	msg := fmt.Sprintln(v...)
	if Lpanic >= l.level {
		l.Output(Lpanic, 2, msg)
	}
	panic(msg)
}

// Panicf uses fmt.Sprintf to construct and log a message, then panics.
func (l *Logger) Panicf(format string, v ...interface{}) {
	msg := fmt.Sprintf(format, v...)
	if Lpanic >= l.level {
		l.Output(Lpanic, 2, msg)
	}
	panic(msg)
}

// Fatal uses fmt.Sprintln to construct and log a message, then calls os.Exit(1).
func (l *Logger) Fatal(v ...interface{}) {
	if Lfatal >= l.level {
		l.Output(Lfatal, 2, fmt.Sprintln(v...))
	}
	os.Exit(1)
}

// Fatalf uses fmt.Sprintf to construct and log a message, then calls os.Exit(1).
func (l *Logger) Fatalf(format string, v ...interface{}) {
	if Lfatal >= l.level {
		l.Output(Lfatal, 2, fmt.Sprintf(format, v...))
	}
	os.Exit(1)
}

// Debug uses fmt.Sprintln to construct and log a message.
func Debug(v ...interface{}) {
	if Ldebug >= _globalL.level {
		_globalL.Output(Ldebug, 2, fmt.Sprintln(v...))
	}
}

// Debugf uses fmt.Sprintf to construct and log a message.
func Debugf(format string, v ...interface{}) {
	if Ldebug >= _globalL.level {
		_globalL.Output(Ldebug, 2, fmt.Sprintf(format, v...))
	}
}

// Info uses fmt.Sprintln to construct and log a message.
func Info(v ...interface{}) {
	if Linfo >= _globalL.level {
		_globalL.Output(Linfo, 2, fmt.Sprintln(v...))
	}
}

// Infof uses fmt.Sprintf to construct and log a message.
func Infof(format string, v ...interface{}) {
	if Linfo >= _globalL.level {
		_globalL.Output(Linfo, 2, fmt.Sprintf(format, v...))
	}
}

// Warn uses fmt.Sprintln to construct and log a message.
func Warn(v ...interface{}) {
	if Lwarn >= _globalL.level {
		_globalL.Output(Lwarn, 2, fmt.Sprintln(v...))
	}
}

// Warnf uses fmt.Sprintf to construct and log a message.
func Warnf(format string, v ...interface{}) {
	if Lwarn >= _globalL.level {
		_globalL.Output(Lwarn, 2, fmt.Sprintf(format, v...))
	}
}

// Error uses fmt.Sprintln to construct and log a message.
func Error(v ...interface{}) {
	if Lerror >= _globalL.level {
		_globalL.Output(Lerror, 2, fmt.Sprintln(v...))
	}
}

// Errorf uses fmt.Sprintf to construct and log a message.
func Errorf(format string, v ...interface{}) {
	if Lerror >= _globalL.level {
		_globalL.Output(Lerror, 2, fmt.Sprintf(format, v...))
	}
}

// Panic uses fmt.Sprintln to construct and log a message, then panics.
func Panic(v ...interface{}) {
	s := fmt.Sprintln(v...)
	if Lpanic >= _globalL.level {
		_globalL.Output(Lpanic, 2, s)
	}
	panic(s)
}

// Panicf uses fmt.Sprintf to construct and log a message, then panics.
func Panicf(format string, v ...interface{}) {
	s := fmt.Sprintf(format, v...)
	if Lpanic >= _globalL.level {
		_globalL.Output(Lpanic, 2, s)
	}
	panic(s)
}

// Fatal uses fmt.Sprintln to construct and log a message, then calls os.Exit(1).
func Fatal(v ...interface{}) {
	if Lfatal >= _globalL.level {
		_globalL.Output(Lfatal, 2, fmt.Sprintln(v...))
	}
	os.Exit(1)
}

// Fatalf uses fmt.Sprintf to construct and log a message, then calls os.Exit(1).
func Fatalf(format string, v ...interface{}) {
	if Lfatal >= _globalL.level {
		_globalL.Output(Lfatal, 2, fmt.Sprintf(format, v...))
	}
	os.Exit(1)
}

// Output writes the output for a logging event.
// The string msg contains the text to print after the prefix specified by the flags of the Logger.
// A newline is appended if the last character of s is not already a newline.
// The level argument specifies the log message level.
// The calldepth argument specifies the count of the number of frames to skip
// when computing the file name and line number if Llongfile or Lshortfile is set.
func Output(level int, calldepth int, msg string) error {
	return _globalL.Output(level, calldepth+1, msg) // +1 for this frame.
}
